#!/usr/bin/env python

#
#                            Stochastic L-Systems
#
#
#                     Daniel Jones <dcjones@cs.washington.edu>
#                                 Nov. 5, 2010
#

'''
sls: stochastic  l-systems
'''

import cairo
import numpy.random
from sls.safe_eval import safe_compile, safe_eval
from numpy         import array, sin, cos, tan, pi, log, abs, sqrt
from functools     import partial
from copy          import copy, deepcopy
from collections   import defaultdict
from sys           import stdout, stderr

# Pi is wrong, angles are specified on a [0,1] scale in terms of tau = 2pi
tau = 2*pi

def weighted_choice( ws ):
    '''
    Given a list of numbers, return i with probability:
        w[i] / sum(ws)
    '''

    if len(ws) == 0: raise IndexError
    if len(ws) == 1: return 0

    z = numpy.random.uniform( high = sum(ws) )
    for (i,w) in enumerate(ws):
        if z <= w: return i
        z -= w

    return len(ws)-1



#
#    L-System Programs
#    -----------------
#    L-Systems generated by stochastic context free grammars (SCFG) that
#    generate a series of primitive drawing commands.  Here, the idea is
#    generalized somewhat so that arbitrary python expressions can be evaluated
#    (devoid context or introspection) to compute the parameters of the
#    drawing commands.
#

def compile_argexp( argexp ):
    return safe_compile( '(' + argexp + ',)' ) if argexp else None


class scfg:
    '''
    A representation of stochastic context free grammar.
    '''

    class op:
        def __init__( self, opcode = None, argexp = None ):
            self.opcode = opcode
            self.argexp = argexp
            self.args   = compile_argexp( argexp )

        def __repr__( self ):
            s = '%s' % self.opcode
            if self.argexp:
                s += '( '
                s += self.argexp
                s += ' )'
            return s

    class rule:
        def __init__( self, nterm, ops, weight=1.0 ):
            self.nterm  = nterm
            self.ops    = ops
            self.weight = weight

        def __repr__( self ):
            s = '%s:%0.2f -> ' % (self.nterm,self.weight)
            s += ''.join(map(repr,self.ops))
            return s


    def __init__( self ):
        self.rules = defaultdict(list)
        self.primitives = \
                   { 'F' : op_forward,
                     'B' : op_backward,
                     'M' : op_move,
                     '+' : op_right,
                     '-' : op_left,
                     '[' : op_push,
                     ']' : op_pop
                     }


    def __call__( self, nterm ):
        if nterm not in self.rules: return None
        i = weighted_choice([ rule.weight for rule in self.rules[nterm] ])
        return self.rules[nterm][i]

    def __repr__( self ):
        s = str()
        for nterm in self.rules:
            for rule in self.rules[nterm]:
                s += '\t' + repr(rule) + '\n'
        return s

    def add_rule( self, rule ):
        self.rules[rule.nterm].append( rule )

    def equivicate( self, a, b ):
        if a in self.primitives:
            self.primitives[b] = self.primitives[a]
        else:
            self.primitives[a] = self.primitives[b]




#
# Section II. Predefined operators
# --------------------------------
# A number of built-in drawing primitives are defined. New primitives may not be
# defined, thus preserving contextualness.
#


class Op:
    def __init__( self, f, def_argexp=None ):
        self.defaultargs = compile_argexp( def_argexp )
        self.f = f

    def __call__( self, s, args=None ):
        argres = None
        if args:
            self.defaultargs = args
        argres = eval_args( s, self.defaultargs, 2 )
        self.f( s, argres )


# convenience decorator
def op_func( defaultargs=None ):
    def op_sub( f ):
        return Op( f, defaultargs )
    return op_sub

@op_func('300/((20/13.0)**k)')
def op_forward( s, args ):
    delta = float(args[0])
    s.line( delta )

@op_func('300/((20/13.0)**k)')
def op_backward( s, args ):
    delta = float(args[0])
    s.line( -delta )

@op_func('w/2.0, h/2.0')
def op_move( s, args ):
    (x,y) = (float(args[0]), float(args[1]))
    s.jump( x, y )


@op_func('0.125')
def op_left( s, args ):
    delta = float(args[0])
    s.turn( -delta )

@op_func('0.125')
def op_right( s, args ):
    delta = float(args[0])
    s.turn( delta )


@op_func()
def op_push( s, args ):
    s.push_state()

@op_func()
def op_pop( s, args ):
    s.pop_state()



#
# Operator argument evaluation
# ----------------------------
# The arguments to the drawing primitives are evaluated as python expressions.
# Basic math and pseudo-random number functions are provided, but there are no
# state changes allowed.
#



def eval_args( T, code, max_eval_time ):

    if code:
        return tuple(safe_eval(
                code     = code,
                context  = T.eval_context,
                max_secs = max_eval_time ))
    else:
        return ()




#
# Rendering
# ---------
# Finally, the grammars are rendered simply by performing a parse of the
# grammar, with a strictly limited depth.
#




class turtle_state:
    '''
    Represents a stored state.  Most of the state is push and poped in the cairo
    context, but some things we must track ourselves.
    '''

    def __init__( self ):
        self.angle    = None
        self.xy       = None

    def dup( self ):
        return deepcopy( self )



class turtle:
    '''
    Drawer of lines.
    '''

    def pos( self ):
        return array( list(self.ctx.get_current_point()) )

    def line( self, d ):
        self.state.xy += d * array( [ sin(self.state.angle * tau),
                                      cos(self.state.angle * tau) ] )
        self.ctx.line_to( *self.state.xy )

    def move( self, d ):
        self.state.xy += d * array( [ sin(self.state.angle * tau),
                                      cos(self.state.angle * tau) ] )
        self.ctx.line_to( *self.state.xy )

    def jump( self, x, y ):
        self.state.xy = array([x,y])
        self.ctx.move_to( *self.state.xy )

    def turn( self, d ):
        self.state.angle += d;

    def push_state( self ):
        self.ctx.save()
        self.state_stack.append( self.state )
        self.state = self.state.dup()

    def pop_state( self ):
        self.ctx.restore()
        self.state = self.state_stack.pop()
        self.jump( *self.state.xy ) # update cairo context

    def __init__( self, ctx ):
        self.ctx   = ctx

        self.state_stack = []
        self.state       = turtle_state()
        self.state.angle = 0.5
        self.state.xy    = self.pos()
        self.k           = 0


        self.eval_context = {
            # allow nothing by default
            '__builtins__' : None,

            'abs'  : abs,
            'log'  : log,
            'sqrt' : sqrt,

            # random functions
            'runif' : numpy.random.uniform,
            'rnorm' : numpy.random.normal,

            # trig functions/constants
            'sin' : sin,
            'cos' : cos,
            'tan' : tan,
            'pi'  : pi,
            'tau' : tau,

            # variables
            'k' : self.k
            }






def render_error( msg ):
    stderr.write( 'Error:' )
    stderr.write( msg )
    exit(1)




def render( surface, grammar, n, start_nterm = 'S', max_pops=None, max_eval_time=10 ):
    '''
    Render the given grammar on the given surface at a depth of n.
    '''


    ctx = cairo.Context(surface)

    # default drawing settings
    ctx.set_line_width( 1.0 )
    ctx.set_source_rgb( 0, 0, 0 )
    ctx.paint()
    ctx.set_source_rgb( 1, 1, 1 )

    # turtle
    T = turtle( ctx )
    T.eval_context['w'] = surface.get_width()
    T.eval_context['h'] = surface.get_height()


    # start out in the bottom middle
    T.jump( surface.get_width() / 2.0, surface.get_height() )


    # watch to make sure evaluation doesn't run out of control
    pop_count = 0

    # operation stack
    S = []
    S.append( [scfg.op('S')] )


    while S:
        ops = S.pop()
        #print ops
        #print S

        pop_count += 1
        if max_pops and pop_count > max_pops:
            break

        for (i,op) in enumerate(ops):

            rule = grammar(op.opcode)

            if op.opcode in grammar.primitives:
                # arguments always default to the last seen
                if op.args:
                    grammar.primitives[op.opcode].defaultargs = op.args

                if len(S) >= n or not rule:
                    #print op
                    turtle.k = len(S) - 1
                    f = grammar.primitives[op.opcode]
                    f( T, op.args )
                    continue

            # treat the opcode as a nonterminal
            if rule and len(S) < n:
                S.append( ops[i+1:] )
                S.append( rule.ops )
                break


    ctx.stroke()


if __name__ == '__main__':
    pass

